# 데이터 결합: concat, merge

## 개념 요약

분석을 위해 여러 소스에서 가져온 데이터를 하나로 합치는 작업은 매우 흔합니다. Pandas는 두 개 이상의 데이터프레임을 결합하는 두 가지 주요 함수, `concat`과 `merge`를 제공합니다.

- **`pd.concat()` (Concatenation)**: 여러 데이터프레임을 축(axis)을 따라 단순히 이어 붙이는 작업을 합니다. 기본적으로 행(row) 방향(axis=0)으로 데이터를 쌓으며, SQL의 `UNION ALL`과 유사한 개념입니다. 열(column) 방향(axis=1)으로 붙일 수도 있습니다.

- **`pd.merge()` (Merging/Joining)**: 하나 이상의 공통된 열(key)을 기준으로 데이터프레임을 결합합니다. SQL의 `JOIN` 문과 매우 유사하며, `inner`, `left`, `right`, `outer` 등 다양한 조인 방식을 지원합니다. 관계형 데이터베이스의 테이블들을 조인하는 것과 같은 원리입니다.

## 적용 가능한 상황

- **`concat` 사용**:
    - 동일한 열 구조를 가진 여러 개의 데이터프레임을 하나로 합칠 때. (e.g., 여러 기간에 걸쳐 수집된 로그 데이터, 여러 지역의 판매 데이터)
    - 구조가 다른 데이터프레임들을 단순히 옆으로(열 방향으로) 나란히 붙이고 싶을 때.

- **`merge` 사용**:
    - 서로 다른 정보를 담고 있지만, '고객 ID', '상품 코드' 등 공통된 식별자(key)를 가진 데이터프레임들을 결합할 때. (e.g., 고객 정보 테이블과 구매 내역 테이블을 '고객 ID'로 결합)
    - 두 데이터 간의 관계(일대일, 일대다, 다대다)를 기반으로 정보를 풍부하게 만들고 싶을 때.

## 구현 방법

### 예제 데이터프레임 생성

```python
import pandas as pd

df1 = pd.DataFrame({'A': ['A0', 'A1', 'A2'],
                    'B': ['B0', 'B1', 'B2']},
                   index=[0, 1, 2])

df2 = pd.DataFrame({'A': ['A3', 'A4', 'A5'],
                    'B': ['B3', 'B4', 'B5']},
                   index=[3, 4, 5])

df3 = pd.DataFrame({'C': ['C0', 'C1', 'C2'],
                    'D': ['D0', 'D1', 'D2']},
                   index=[0, 1, 2])

# merge를 위한 예제 데이터
left = pd.DataFrame({'key': ['K0', 'K1', 'K2', 'K3'],
                     'A': ['A0', 'A1', 'A2', 'A3'],
                     'B': ['B0', 'B1', 'B2', 'B3']})

right = pd.DataFrame({'key': ['K0', 'K1', 'K4', 'K5'],
                      'C': ['C0', 'C1', 'C4', 'C5'],
                      'D': ['D0', 'D1', 'D4', 'D5']})
```

### 1. `pd.concat()`

- **용도**: 여러 데이터프레임을 수직 또는 수평으로 이어 붙입니다.
- **주의사항**: 기본적으로 `axis=0` (행 방향)으로 동작합니다. `ignore_index=True` 옵션을 사용하지 않으면 기존 인덱스가 그대로 유지되어 중복 인덱스가 발생할 수 있습니다. 열 이름이 다른 데이터프레임을 합칠 경우, 해당 열이 없는 데이터프레임에는 `NaN`이 채워집니다.
- **코드 예시**:
  ```python
  # 행 방향으로 결합 (기본값)
  result_row = pd.concat([df1, df2])
  print("--- Row-wise concat ---")
  print(result_row)

  # 인덱스 재설정
  result_row_ignore = pd.concat([df1, df2], ignore_index=True)
  print("\n--- Row-wise concat with ignore_index=True ---")
  print(result_row_ignore)

  # 열 방향으로 결합
  result_col = pd.concat([df1, df3], axis=1)
  print("\n--- Column-wise concat (axis=1) ---")
  print(result_col)
  ```
- **결과 해석**:
  - `pd.concat([df1, df2])`는 `df1` 아래에 `df2`를 그대로 붙여 6행 2열의 데이터프레임을 만듭니다. 인덱스는 `0, 1, 2, 3, 4, 5`로 유지됩니다.
  - `ignore_index=True`를 사용하면 기존 인덱스를 무시하고 `0, 1, 2, 3, 4, 5`로 새로운 인덱스를 생성합니다.
  - `axis=1`을 사용하면 `df1` 옆에 `df3`를 붙여 3행 4열의 데이터프레임을 만듭니다. 두 데이터프레임의 인덱스가 같으므로 정상적으로 옆으로 결합됩니다.

- **주요 하이퍼파라미터 (인자)**:
    - `objs`: 결합할 데이터프레임 객체들의 리스트 또는 튜플. `[df1, df2, ...]`
    - `axis`: 결합할 축 방향. `0` (기본값)은 행 방향(위아래), `1`은 열 방향(좌우).
    - `join`: 다른 축의 인덱스를 처리하는 방법. `'outer'` (기본값)는 모든 인덱스를 포함(합집합), `'inner'`는 공통된 인덱스만 포함(교집합).
    - `ignore_index`: `True`로 설정하면 기존 인덱스를 무시하고 0부터 시작하는 새로운 인덱스를 생성. 기본값은 `False`.

### 2. `pd.merge()`

- **용도**: 공통 열(key)을 기준으로 두 데이터프레임을 SQL처럼 조인합니다.
- **주의사항**: `on` 인자를 명시하지 않으면, 두 데이터프레임에 공통으로 존재하는 모든 열을 조인 키로 사용합니다. 조인 키의 이름이 두 데이터프레임에서 다를 경우 `left_on`과 `right_on`을 사용합니다.
- **코드 예시**:
  ```python
  # Inner Join (기본값): 양쪽에 모두 존재하는 키만 결합
  inner_join = pd.merge(left, right, on='key')
  print("--- Inner Join ---")
  print(inner_join) # K0, K1만 포함

  # Left Outer Join: 왼쪽(left) 데이터프레임의 모든 키를 유지
  left_join = pd.merge(left, right, on='key', how='left')
  print("\n--- Left Join ---")
  print(left_join) # K0, K1, K2, K3 모두 포함. K2, K3의 C, D열은 NaN

  # Outer Join: 양쪽의 모든 키를 유지
  outer_join = pd.merge(left, right, on='key', how='outer')
  print("\n--- Outer Join ---")
  print(outer_join) # K0, K1, K2, K3, K4, K5 모두 포함
  ```
- **결과 해석**:
  - **Inner Join**: `left`와 `right`에 공통으로 존재하는 `key`인 'K0'와 'K1'에 대해서만 데이터가 결합됩니다.
  - **Left Join**: `left` 데이터프레임의 모든 `key`('K0'~'K3')가 유지됩니다. `right`에 해당 `key`가 없는 'K2', 'K3'의 경우, `right`에서 온 열(`C`, `D`)의 값은 `NaN`으로 채워집니다.
  - **Outer Join**: 두 데이터프레임에 존재하는 모든 `key`('K0'~'K5')가 결과에 포함됩니다. 짝이 없는 데이터는 `NaN`으로 채워집니다.

- **주요 하이퍼파라미터 (인자)**:
    - `left`, `right`: 결합할 두 개의 데이터프레임.
    - `how`: 조인 방식을 지정. `'inner'` (기본값), `'left'`, `'right'`, `'outer'`.
    - `on`: 조인 키로 사용할 열 이름. 두 데이터프레임에 모두 존재해야 함.
    - `left_on`, `right_on`: 조인 키의 이름이 왼쪽과 오른쪽 데이터프레임에서 다를 때 각각 지정.
    - `suffixes`: 조인 키를 제외한 나머지 열 중 이름이 겹칠 경우, 각 열 이름에 붙일 접미사. 기본값은 `('_x', '_y')`.
    - `indicator`: `True`로 설정하면, `_merge`라는 열이 추가되어 각 행이 어떤 조인에 의해 생성되었는지(`'left_only'`, `'right_only'`, `'both'`)를 보여줌.

## 장단점 및 대안

| 함수 | 장점 | 단점 | 대안/팁 |
|---|---|---|---|
| **`pd.concat()`** | 사용법이 간단하고 직관적임. 여러 개의 데이터프레임을 한 번에 합칠 수 있음. | 공통 키 기반의 복잡한 데이터 연결 로직에는 부적합. | `df.append()`는 두 개의 데이터프레임을 행 방향으로 합치는 더 간단한 방법이었으나, Pandas 1.4.0부터 공식적으로 deprecated 되었으므로 `concat` 사용이 권장됨. |
| **`pd.merge()`** | SQL 조인과 유사하여 관계형 데이터 처리에 매우 강력하고 유연함. | 두 개의 데이터프레임만 결합 가능 (여러 개를 합치려면 연쇄적으로 사용해야 함). 대용량 데이터 조인 시 메모리 사용량과 속도에 주의 필요. | `df.join()` 메서드는 인덱스를 기준으로 조인할 때 더 편리한 인터페이스를 제공함. `merge`는 내부적으로 `join`을 활용하는 더 일반적인 함수임. |

**`merge` vs `join` 메서드**

- `pd.merge()`는 함수이고, `df.join()`은 데이터프레임의 메서드입니다.
- `merge`는 기본적으로 **열(column)**을 기준으로 조인합니다.
- `join`은 기본적으로 **인덱스(index)**를 기준으로 조인합니다.
- `df1.join(df2)`는 `pd.merge(df1, df2, left_index=True, right_index=True, how='left')`와 유사하게 동작합니다. 따라서 인덱스 기반 조인이 필요할 때는 `join`이 더 간결한 코드를 제공합니다.

