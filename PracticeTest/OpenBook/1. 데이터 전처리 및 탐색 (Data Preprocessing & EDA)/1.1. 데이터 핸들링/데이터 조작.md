
# 데이터 조작

## 개념 요약

데이터 조작은 원본 데이터를 분석 목적에 맞게 변형하고 가공하는 모든 과정을 의미합니다. Pandas는 행과 열을 선택, 추가, 삭제, 변경하고, 데이터의 형식을 바꾸며, 함수를 적용하는 등 강력하고 유연한 데이터 조작 기능을 제공합니다. 이는 데이터 전처리 및 피처 엔지니어링의 핵심적인 부분입니다.

- **행/열 선택 및 변경**: 특정 조건에 맞는 행(row)이나 필요한 열(column)을 추출하고, 값을 새로운 값으로 변경합니다. `.loc`와 `.iloc`가 핵심적인 역할을 합니다.
- **데이터 타입 변경**: 분석에 적합한 형태로 데이터의 타입(Dtype)을 변환합니다. 예를 들어, 문자열로 저장된 숫자를 수치형으로, 혹은 그 반대로 변경합니다. `astype()` 메서드가 주로 사용됩니다.
- **필터링**: 하나 이상의 조건을 만족하는 데이터 행을 추출합니다. 불리언 인덱싱(Boolean Indexing)을 통해 구현됩니다.
- **`apply` / `map`**: 행 또는 열 전체에 복잡한 연산을 적용하거나, 시리즈의 각 원소에 함수를 일괄적으로 적용합니다.

## 적용 가능한 상황

- **변수 선택**: 분석에 필요한 변수(열)만 선택하거나, 불필요한 변수를 제거할 때.
- **데이터 클리닝**: 특정 조건을 만족하는 이상치를 제거하거나, 잘못 입력된 값을 수정할 때.
- **파생 변수 생성**: 기존 변수들을 조합하여 새로운 의미를 갖는 변수(열)를 만들 때. (e.g., '키'와 '몸무게'로 'BMI'를 계산)
- **데이터 정규화**: 범주형 변수를 수치형으로 변환하거나(e.g., '남성'/'여성' -> 0/1), 수치형 변수의 단위를 변경할 때.
- **사용자 정의 함수 적용**: Pandas에서 기본으로 제공하지 않는 복잡한 로직을 데이터의 각 부분에 적용해야 할 때.

## 구현 방법

### 예제 데이터프레임 생성

```python
import pandas as pd
import numpy as np

data = {'Group': ['A', 'B', 'A', 'B', 'A'],
        'Category': ['X', 'Y', 'X', 'Z', 'Y'],
        'Value1': [10, 20, 30, 40, 50],
        'Value2': ['100', '200', '300', '400', '500']}
df = pd.DataFrame(data)
```

### 1. 행/열 선택 및 변경

- **용도**: 데이터의 특정 부분을 추출하거나 수정합니다.
- **주의사항**: `.loc`는 레이블(이름) 기반, `.iloc`는 정수 위치 기반입니다. 명확히 구분해서 사용해야 실수를 줄일 수 있습니다. 특히, 연속되지 않은 여러 행/열을 선택할 때는 리스트 `[]`를 사용해야 합니다.
- **코드 예시**:
  ```python
  # 열 선택
  print(df['Value1']) # Series 형태로 반환
  print(df[['Group', 'Value1']]) # DataFrame 형태로 반환

  # 행 선택 (loc, iloc)
  print(df.loc[0]) # 인덱스 레이블이 0인 행
  print(df.iloc[0:2]) # 0, 1번 위치의 행 (2는 포함 안 됨)
  print(df.loc[[0, 3]]) # 0, 3번 인덱스 레이블의 행

  # 특정 행/열의 값 선택
  print(df.loc[0, 'Value1']) # 10
  print(df.at[0, 'Value1']) # 단일 값 선택 시 더 빠름

  # 값 변경
  df.loc[df['Group'] == 'A', 'Value1'] = 99 # 조건에 맞는 행의 특정 열 값 변경
  print(df)
  ```
- **결과 해석**: `.loc`와 `.iloc`를 사용하여 행과 열을 유연하게 선택할 수 있습니다. 조건부 필터링과 결합하여 특정 조건을 만족하는 데이터의 값을 효율적으로 변경할 수 있습니다.

### 2. 데이터 타입 변경 (`astype`)

- **용도**: 열의 데이터 타입을 변환합니다.
- **주의사항**: 변환하려는 열에 부적절한 값(e.g., 숫자로 바꿀 열에 문자 포함)이나 결측치(NaN)가 있으면 에러가 발생할 수 있습니다. `pd.to_numeric`의 `errors` 인자를 사용하면 이런 상황을 제어할 수 있습니다.
- **코드 예시**:
  ```python
  print(f"Original Dtype of Value2: {df['Value2'].dtype}")

  # 'Value2' 열을 정수형으로 변경
  df['Value2'] = df['Value2'].astype(int)
  print(f"New Dtype of Value2: {df['Value2'].dtype}")

  # pd.to_numeric 사용 (에러 처리 기능 포함)
  s = pd.Series(['1', '2', 'a'])
  s_numeric = pd.to_numeric(s, errors='coerce') # 'a'는 NaN으로 변환됨
  print(s_numeric)
  ```
- **결과 해석**: `astype(int)`를 통해 `Value2` 열이 `object`(문자열) 타입에서 `int64`(정수) 타입으로 성공적으로 변환되었습니다. `pd.to_numeric`은 `errors='coerce'` 옵션을 통해 변환 불가능한 값을 강제로 `NaN`으로 만들어주어, 데이터 클리닝 시 유용합니다.

### 3. 필터링 (Boolean Indexing)

- **용도**: 특정 조건을 만족하는 행을 추출합니다.
- **주의사항**: 여러 조건을 결합할 때는 `&` (AND), `|` (OR) 연산자를 사용하며, 각 조건은 반드시 괄호 `()`로 묶어주어야 합니다. (e.g., `(df['A'] > 1) & (df['B'] < 10)`)
- **코드 예시**:
  ```python
  # 단일 조건 필터링
  df_group_b = df[df['Group'] == 'B']
  print(df_group_b)

  # 다중 조건 필터링
  df_filtered = df[(df['Group'] == 'A') & (df['Value1'] > 20)]
  print(df_filtered)

  # isin을 사용한 필터링
  df_isin = df[df['Category'].isin(['X', 'Y'])]
  print(df_isin)
  ```
- **결과 해석**: 불리언 시리즈(True/False로 구성된 Series)를 데이터프레임의 인덱서로 사용하면, `True`에 해당하는 행만 선택됩니다. `isin` 메서드는 특정 열의 값이 리스트에 포함된 여러 값 중 하나에 해당하는지 여부를 검사할 때 유용합니다.

### 4. `apply` / `map`

- **용도**: 데이터에 함수를 일괄적으로 적용합니다.
- **주의사항**: `apply`는 DataFrame의 행 또는 열 전체에, `map`은 Series의 각 원소에 적용됩니다. `applymap`은 DataFrame의 모든 원소에 적용됩니다. 일반적으로 벡터화된 연산(Numpy/Pandas 기본 연산)이 `apply`보다 훨씬 빠르므로, 가능한 한 벡터화 연산을 먼저 고려해야 합니다.
- **코드 예시**:
  ```python
  # apply: 열(axis=0) 또는 행(axis=1) 단위로 함수 적용
  def get_stats(x):
      return pd.Series([x.min(), x.max(), x.mean()], index=['min', 'max', 'mean'])
  
  # Value1, Value2 열에 대해 통계량 계산
  stats_df = df[['Value1', 'Value2']].apply(get_stats)
  print(stats_df)

  # apply with lambda (행 단위 연산)
  df['Value_Sum'] = df.apply(lambda row: row['Value1'] + row['Value2'], axis=1)
  print(df)

  # map: Series의 각 원소에 함수 또는 딕셔너리 적용
  df['Group_Code'] = df['Group'].map({'A': 1, 'B': 2})
  print(df)
  ```
- **결과 해석**:
  - `apply`를 사용하여 각 열의 최소, 최대, 평균값을 계산했습니다.
  - `lambda` 함수와 `apply(axis=1)`를 조합하여 각 행의 `Value1`과 `Value2`를 더한 새로운 열 `Value_Sum`을 생성했습니다.
  - `map`을 사용하여 `Group` 열의 문자열 값('A', 'B')을 숫자(1, 2)로 매핑하는 '인코딩' 작업을 수행했습니다.

## 장단점 및 대안

| 기능 | 장점 | 단점 | 대안/팁 |
|---|---|---|---|
| **행/열 선택** | `.loc`, `.iloc`를 통해 명시적이고 유연한 선택 가능 | 문법이 다소 복잡하고, 초보자가 실수하기 쉬움 (`SettingWithCopyWarning`) | 단일 값 접근에는 `at`, `iat`이 더 빠름. 열 선택 시 `df.Value1`과 같은 속성 접근도 가능하지만, 공백이나 특수문자가 있는 열 이름에는 사용할 수 없어 `df['Value1']` 방식이 더 안전함. |
| **`astype`** | 간단한 문법으로 데이터 타입을 쉽게 변경 가능 | 변환 불가능한 값이 있을 경우 에러 발생 | `pd.to_numeric`, `pd.to_datetime`, `pd.to_timedelta` 등 특정 타입 변환에 특화된 함수들은 `errors` 인자를 통해 더 정교한 에러 처리가 가능함. |
| **필터링** | 직관적이고 강력한 조건 기반 데이터 추출 | 여러 조건을 중첩할 때 괄호 사용을 잊기 쉬움 | 복잡한 조건은 변수로 분리하여 가독성을 높일 수 있음. `df.query('Group == "A" and Value1 > 20')`는 문자열 형태로 쿼리를 작성하여 더 간결하게 필터링할 수 있는 대안임. |
| **`apply`/`map`** | 복잡하고 사용자 정의된 로직을 쉽게 적용 가능 | 벡터화된 연산에 비해 속도가 매우 느림 | 가능한 한 `+`, `*` 와 같은 기본 연산자나, `np.log()`, `str.lower()` 등 Pandas/Numpy에 내장된 벡터화 함수를 먼저 사용해야 함. `map`은 딕셔너리를 인자로 받을 수 있어 인코딩에 매우 효율적임. |
