# 생존 분석: Kaplan-Meier 생존 곡선, Log-rank test

## 개념 요약

생존 분석(Survival Analysis)은 특정 사건(Event)이 발생하기까지의 시간(Time-to-event)을 분석하는 통계적 방법론입니다. 여기서 사건은 사망, 질병 재발, 고객 이탈, 기계 고장 등 다양하게 정의될 수 있으며, 시간은 사건이 발생하기까지의 기간을 의미합니다. 생존 분석의 핵심 특징은 '중도 절단(Censoring)' 데이터를 다룰 수 있다는 점인데, 이는 연구 기간 동안 사건이 발생하지 않았거나 추적 관찰이 중단된 경우를 의미합니다.

## 적용 가능한 상황

- **의학/생물학**: 환자의 생존 기간 분석, 특정 치료법의 효과 비교, 질병 재발까지의 시간 예측.
- **산업 공학**: 기계나 부품의 수명 예측, 고장 발생까지의 시간 분석.
- **경제학/마케팅**: 고객의 서비스 이탈(Churn) 시점 예측, 대출 상환 기간 분석.
- **사회학**: 특정 사회 현상(예: 결혼, 이직) 발생까지의 시간 분석.

## 구현 방법

### 1. Kaplan-Meier 생존 곡선

#### 용도

Kaplan-Meier 생존 곡선은 시간에 따른 생존 확률을 추정하고 시각화하는 비모수적 방법입니다. 특정 시점까지 사건이 발생하지 않고 생존할 확률을 계단 함수 형태로 보여주며, 그룹별 생존율을 비교하는 데 유용합니다.

#### 주의사항

- Kaplan-Meier 곡선은 공변량(Covariates)의 영향을 직접적으로 모델링하지 않습니다. 즉, 다른 변수들의 영향을 통제한 상태에서의 생존율을 보여주지는 않습니다.
- 그룹 간 비교 시에는 통계적 유의성을 판단하기 위해 Log-rank test와 같은 추가적인 검정이 필요합니다.
- 중도 절단된 데이터가 많을수록 곡선의 신뢰도가 떨어질 수 있습니다.

#### 코드 예시 (`lifelines` 라이브러리 사용)

`lifelines`는 파이썬에서 생존 분석을 위한 강력한 라이브러리입니다. 설치가 필요합니다 (`pip install lifelines`).

```python
import pandas as pd
import numpy as np
from lifelines import KaplanMeierFitter
from lifelines.plotting import add_at_risk_counts
import matplotlib.pyplot as plt

# 1. 데이터 준비
# 예시 데이터: 환자 ID, 관찰 시간(duration), 사건 발생 여부(event, 1=사건 발생, 0=중도 절단)
# 그룹 정보(group) 추가
data = {
    'id': range(1, 21),
    'duration': [10, 12, 15, 20, 22, 25, 28, 30, 35, 40, 
                 11, 13, 16, 21, 23, 26, 29, 31, 36, 41],
    'event': [1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 
              1, 0, 1, 1, 0, 1, 0, 1, 1, 0],
    'group': ['A']*10 + ['B']*10
}
df = pd.DataFrame(data)

# 2. Kaplan-Meier Fitter 객체 생성 및 학습
kmf = KaplanMeierFitter()

# 전체 데이터에 대한 생존 곡선
kmf.fit(df['duration'], event_observed=df['event'])

plt.figure(figsize=(10, 6))
kmf.plot_survival_function()
plt.title('Kaplan-Meier Survival Function (Overall)')
plt.xlabel('Time')
plt.ylabel('Survival Probability')
plt.grid(True)
plt.show()

# 그룹별 생존 곡선
plt.figure(figsize=(10, 6))
for name, grouped_df in df.groupby('group'):
    kmf.fit(grouped_df['duration'], event_observed=grouped_df['event'], label=name)
    kmf.plot_survival_function()

plt.title('Kaplan-Meier Survival Function by Group')
plt.xlabel('Time')
plt.ylabel('Survival Probability')
plt.grid(True)
plt.legend()
add_at_risk_counts(kmf, ax=plt.gca()) # 각 시점별 위험군 수 표시
plt.show()

# 3. 중앙 생존 시간 (Median Survival Time) 확인
print("--- 중앙 생존 시간 ---")
print(f"전체 데이터 중앙 생존 시간: {kmf.median_survival_time_}")

for name, grouped_df in df.groupby('group'):
    kmf.fit(grouped_df['duration'], event_observed=grouped_df['event'])
    print(f"그룹 {name} 중앙 생존 시간: {kmf.median_survival_time_}")
```

#### 하이퍼파라미터 설명

`KaplanMeierFitter` 클래스에는 직접적인 하이퍼파라미터는 없지만, `fit` 메서드의 인자들이 중요합니다.

- `durations`: 각 관측치의 관찰 시간(또는 사건 발생까지의 시간)을 담은 배열 또는 Series입니다.
- `event_observed`: 각 관측치에서 사건이 발생했는지(1) 또는 중도 절단되었는지(0)를 나타내는 불리언 또는 이진 배열/Series입니다.
- `label`: 플롯에 표시될 곡선의 레이블입니다.

#### 결과 해석 방법

- **생존 곡선**: 곡선이 가파르게 떨어질수록 사건 발생률이 높다는 것을 의미합니다. 곡선이 높은 위치에 있을수록 생존 확률이 높습니다.
- **중앙 생존 시간**: 생존 확률이 0.5(50%)가 되는 시점의 시간입니다. 이는 전체 관측치의 절반이 사건을 경험하는 데 걸리는 시간을 나타냅니다.
- **위험군 수 (At-risk counts)**: 각 시점별로 아직 사건을 경험하지 않고 추적 관찰 중인 관측치의 수를 나타냅니다. 이 수가 너무 적어지면 생존 곡선의 신뢰도가 낮아질 수 있습니다.

---

### 2. Log-rank test

#### 용도

Log-rank test는 두 개 이상의 그룹 간 생존 곡선에 통계적으로 유의미한 차이가 있는지를 검정하는 비모수적 가설 검정 방법입니다. 예를 들어, 새로운 치료법을 받은 환자 그룹과 기존 치료법을 받은 환자 그룹의 생존율에 차이가 있는지 비교할 때 사용됩니다.

#### 주의사항

- **비례 위험 가정 (Proportional Hazards Assumption)**: Log-rank test는 그룹 간의 위험률(Hazard Rate)이 시간에 따라 일정하게 비례한다는 가정을 전제로 합니다. 이 가정이 위배될 경우 검정 결과의 신뢰도가 떨어질 수 있습니다.
- **공변량 통제 불가**: Kaplan-Meier와 마찬가지로 다른 공변량의 영향을 통제하지 않고 단순히 그룹 간의 차이만을 비교합니다.

#### 코드 예시 (`lifelines` 라이브러리 사용)

```python
import pandas as pd
from lifelines.statistics import logrank_test

# 1. 데이터 준비 (Kaplan-Meier 예시와 동일)
data = {
    'id': range(1, 21),
    'duration': [10, 12, 15, 20, 22, 25, 28, 30, 35, 40, 
                 11, 13, 16, 21, 23, 26, 29, 31, 36, 41],
    'event': [1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 
              1, 0, 1, 1, 0, 1, 0, 1, 1, 0],
    'group': ['A']*10 + ['B']*10
}
df = pd.DataFrame(data)

# 그룹 A와 B 데이터 분리
df_A = df[df['group'] == 'A']
df_B = df[df['group'] == 'B']

# 2. Log-rank test 수행
# duration_A, event_observed_A: 그룹 A의 관찰 시간과 사건 발생 여부
# duration_B, event_observed_B: 그룹 B의 관찰 시간과 사건 발생 여부
results = logrank_test(df_A['duration'], df_B['duration'], 
                       event_observed_A=df_A['event'], event_observed_B=df_B['event'])

print("--- Log-rank test 결과 ---")
results.print_summary()

# p-value 확인
print(f"p-value: {results.p_value:.4f}")

# 가설 검정
alpha = 0.05
if results.p_value < alpha:
    print(f"유의수준 {alpha}에서 귀무가설(두 그룹의 생존 곡선에 차이가 없다)을 기각합니다.")
    print("-> 두 그룹의 생존 곡선에는 통계적으로 유의미한 차이가 있습니다.")
else:
    print(f"유의수준 {alpha}에서 귀무가설(두 그룹의 생존 곡선에 차이가 없다)을 기각할 수 없습니다.")
    print("-> 두 그룹의 생존 곡선에는 통계적으로 유의미한 차이가 있다고 보기 어렵습니다.")
```

#### 하이퍼파라미터 설명

`logrank_test` 함수의 주요 인자는 다음과 같습니다.

- `durations_A`, `durations_B`: 비교할 두 그룹의 관찰 시간을 담은 배열 또는 Series입니다.
- `event_observed_A`, `event_observed_B`: 비교할 두 그룹의 사건 발생 여부를 나타내는 배열 또는 Series입니다.
- `alpha`: 유의수준을 설정합니다. 기본값은 0.05입니다.

#### 결과 해석 방법

- **p-value**: Log-rank test의 핵심 결과입니다. 일반적으로 p-value가 유의수준(예: 0.05)보다 작으면 귀무가설(두 그룹의 생존 곡선에 차이가 없다)을 기각하고, 두 그룹 간 생존 곡선에 통계적으로 유의미한 차이가 있다고 결론 내립니다.
- **test_statistic**: 검정 통계량 값입니다. 이 값이 클수록 두 그룹 간 차이가 크다는 것을 의미합니다.

## 장단점 및 대안

| 기법 | 장점 | 단점 |
|---|---|---|
| **Kaplan-Meier 생존 곡선** | - 직관적인 생존 확률 시각화<br>- 중도 절단 데이터 처리 가능<br>- 비모수적 방법으로 분포 가정 불필요 | - 공변량의 영향 모델링 불가<br>- 그룹 간 통계적 비교에 한계 |
| **Log-rank test** | - 두 그룹 이상 간 생존 곡선 비교의 통계적 유의성 검정<br>- 비모수적 방법 | - 비례 위험 가정 필요<br>- 공변량의 영향 통제 불가 |

### 대안

- **Cox 비례 위험 모형 (Cox Proportional Hazards Model)**: 여러 공변량(나이, 성별, 치료 방법 등)의 영향을 동시에 고려하여 생존 시간에 미치는 영향을 분석할 수 있는 회귀 모형입니다. 비례 위험 가정을 전제로 합니다.
    - `lifelines.CoxPHFitter`를 사용합니다.
- **가속 수명 모형 (Accelerated Failure Time, AFT Model)**: Cox 모형과 유사하게 공변량을 포함하지만, 위험률이 아닌 생존 시간에 직접적으로 영향을 미치는 요인을 모델링합니다. 특정 분포(예: Weibull, Exponential)를 가정합니다.
- ** parametric survival models**: 생존 시간에 대한 특정 확률 분포(예: 지수 분포, 와이블 분포)를 가정하고 모형을 구축하는 방법입니다.
